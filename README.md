Этот репозиторий был создан для практического изучения JUnit по книге "Принципы юнит-тестирования" Владимира Хорикова. Этот материал подойдет новичкам по тиму меня, которые только начинают разбираться в этой теме.
Метрика - процент покрытия тестом исходного кода.
Подробнее о метриках (для каждой метрики есть код с разъяснениями в комментариях. Из утилит для проверки подойдет JaCoCo):
  1. Code coverage (test coverage) = (Количество выполненных строк кода) / (Общее количество строк кода). Нельзая всешда быть уверенным в этой метрике: более компактный код может выдать хороший результат, но при этом весь процент входа может быть даже не покрыт
  2. Branch coverage = (Количество покрытых ветветй) / (Общее количество ветвей). Показывает более точные результаты, так как опирается на управлящие конструкции if и switch. Однако даже у такой метрики есть проблемы. Во-первых: остутсвие проверки косвенных результатов, а во-вторых, отсутвие проверки во внешних библиотеках.

Нельзая стопроцентно доверять метрикам: низкий процент явный - признак плохих тестов, но выский, в своюй очеред - нет. Считайте метрики индикатором, но не целью.

Но как же тогда определить качество своих тестов? Проверять каждый тест по отдельности самостоятельно. 
Есть базовый набор критериев, которым должны отвечать выши тесты:
     1. Интегрированы в цикл разработки.
     2. Сконцентрированы на самой важной части вашей системы, а именнь бизнес-логике. Все остальные части можно            разделить на: инфрастуктурный код, внешние сервисы и зависимости, связывющий код. Им также стоит уделять              внимание, но не слишком много.
     3. Дают максимальную защиту от багов.
     4. Требует минимальные затраты на сопровождение.

О юнит-тестах в целом:
  Юнит-тест - автоматизированный тест, который проверяет определенный API, перед этим илзолировав его, причем делает это быстро. Сущесвует две школы юнит-тесторивания: лондонская и классическая. И их отличие в основном заключется в понимании слова "изоляция" в этом контексте. По мнению лондонской школы, все классы, от которых зависит тестируемый API должны быть заменены на тестовые заглушки (test double или прокси). Так достигается главное правило юнит-тестов - тестирование одного класса (то есть юнита) за раз. В классической школе все немного проще: изолируются не сами  классы, а только тесты. При этом юнитом может считаться уже набор классов.
О классификации зависимостей:
  1. Совместные - завимисимость, к которой могут иметь доступ несколько тестов и при этом они могу влиять друг на друга через нее.
  2. Приватная - зависимость, которая не ялвятеся совмествной
  3. Внепроцессорая - зависимость, находящаяся вне процесса приложения. Рассмотрим два примера. Если есть БД на отдельном сервере, к которой подключаются тесты - то это совместная внепроцессорная зависимость. Если каждый тест разворачивает БД в докере и использует его лично - то это внепроцессорная приватная зависимость.
Также допускается использование stateless (без состояния) или values ( с неизменяемым состоянием) объектов без моков. Однако моки могут помочь ускорить выполнение тестов. 






Определения:
  Метрика - процент покрытия юнит-тестом исходного кода
  Test double - успрощенный объект, с API другого объекта, используемый в тестировании.
  SUT - system under test
  MUT - method under test
  Коллаборатор - зависимость в SUT
  Мок - особая разновидность тестовой заглушки, которая позволяет проанализировать взаимодейтсвия между тестируемой системой и ее коллабораторами 
